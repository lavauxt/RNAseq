
# https://github.com/ebi-gene-expression-group/atlas-gene-annotation-manipulation
# https://training.galaxyproject.org/training-material/topics/single-cell/tutorials/alevin-commandline/tutorial.html
# https://training.galaxyproject.org/training-material/topics/single-cell/
# https://satijalab.org/seurat/articles/pbmc3k_tutorial
# https://satijalab.org/seurat/articles/sctransform_vignette.html

# https://hbctraining.github.io/scRNA-seq/lessons/pseudobulk_DESeq2_scrnaseq.html for DESeq2 pseudo bulk analysis (sex, batch effect, etc.)

# Seurat analysis from alevin
# Alevin works in two phases. 
# In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, 
# and creates a lightweight data-structure for fast-look up and correction of the CB. 
# In the second round, Alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, 
# identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. 
# Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated.
# based on https://combine-lab.github.io/alevin-tutorial/2018/alevin-seurat/

# nCount_RNA: number of UMIs per cell
# nFeature_RNA: number of genes detected per cell

# https://cran.r-project.org/web/packages/scRNAstat/scRNAstat.pdf
# https://bioconductor.org/packages/3.18/bioc/manuals/scran/man/scran.pdf

suppressPackageStartupMessages({
  library(Seurat)
  library(tximport)
  library(eds)
  library(dplyr)
  library(optparse)
  library(SingleR)
  library(celldex)
  library(tidyverse)
  library(ggplot2)
  library(pheatmap)
  library(monocle3) 
})

setwd("/app/scripts/ScRNASeq/")
getwd()
# Load SexScoring function from an external file
source("SexScore.R")
source("Sex_related_gene.R")

option_list <- list(
  make_option(c("-f", "--files"), type="character", default=NULL, 
              help="Path to a file containing a list of input files", metavar="character"),
  make_option(c("-o", "--output"), type="character", default="output", 
              help="Directory to save output files", metavar="character"),
  make_option(c("-p", "--prefix"), type = "character", default = "10X", 
              help = "Project name prefix", metavar = "character"),
  make_option(c("-s", "--sample_id"), type = "character", default = "Sample", 
              help = "Sample ID", metavar = "character"),
  make_option(c("--min_genes"), type="numeric", default=350, 
              help="Minimum number of genes per cell [default %default]", metavar="number"),
  make_option(c("--max_genes"), type="numeric", default=4000, 
              help="Maximum number of genes per cell [default %default]", metavar="number"),
  make_option(c("--max_mito"), type="numeric", default=15, 
              help="Maximum percentage of mitochondrial transcripts [default %default]", metavar="number"),
  make_option(c("--min_housekeeping_expr"), type="numeric", default=55, 
              help="Minimum expression of housekeeping genes per cell [default %default]", metavar="number"),
  make_option(c("--remove_ribo"), type="logical", default=FALSE, 
              help="Remove ribosomal genes from the data [default %default]", metavar="logical"),
  make_option(c("--species"), type="character", default="mouse", 
              help="Species for the analysis ('mouse' or 'human') [default %default]", metavar="character"),
  make_option(c("--cell_cycle_regression"), type="logical", default=FALSE, 
              help="Perform cell cycle regression [default %default]", metavar="logical"),
  make_option(c("--sex_scoring"), type="logical", default=FALSE, 
              help="Perform sex scoring regression [default %default]", metavar="logical")
)

opt_parser <- OptionParser(option_list=option_list)
opt <- parse_args(opt_parser)

if (is.null(opt$files)) {
  print_help(opt_parser)
  stop("File path must be provided. See --help for details.", call.=FALSE)
}

input_files <- unlist(strsplit(opt$files, ","))

if (!dir.exists(opt$output)) {
  dir.create(opt$output, recursive = TRUE)
}

# Define housekeeping file based on the specified species
if (tolower(opt$species) == "human") {
  housekeeper_file <- "/app/scripts/ScRNASeq/Housekeeper_human.R"
  mito_pattern <- "^MT-"
  hb_pattern <- "^Hb"
  ribo_patterns <- c("^RPS", "^RPL")
  female.features <- female.features.human
  male.features <- male.features.human
} else if (tolower(opt$species) == "mouse") {
  housekeeper_file <- "/app/scripts/ScRNASeq/Housekeeper_mouse.R"
  mito_pattern <- "^mt-"
  hb_pattern <- "^Hb"
  ribo_patterns <- c("^Rp")
  female.features <- female.features.mouse
  male.features <- male.features.mouse
} else {
  stop("Invalid species specified. Use 'human' or 'mouse'.", call.=FALSE)
}

# Source the file containing housekeeping genes
source(housekeeper_file)

# Load reference datasets based on the specified species
if (tolower(opt$species) == "human") {
  hpca <- celldex::HumanPrimaryCellAtlasData()
  dice <- celldex::DatabaseImmuneCellExpressionData()
  housekeeper_genes <- housekeeper_human
} else if (tolower(opt$species) == "mouse") {
  hpca <- celldex::MouseRNAseqData()
  dice <- celldex::ImmGenData()
  housekeeper_genes <- housekeeper_mouse
} else {
  stop("Invalid species specified. Use 'human' or 'mouse'.", call.=FALSE)
}

# Add reference-specific labels
hpca$label.main <- paste0(toupper(opt$species), '.', hpca$label.main)
dice$label.main <- paste0(toupper(opt$species), '.', dice$label.main)

# Create a combined reference based on shared genes
shared <- intersect(rownames(hpca), rownames(dice))
combined <- cbind(hpca[shared,], dice[shared,])

# Start script
for (file in input_files) {
  if (!file.exists(file)) {
    warning(sprintf("File %s does not exist. Skipping.", file))
    next
  }

  # Import data
  txi <- tximport(file, type="alevin")
  
  # Create Seurat Object
  project_name <- paste(opt$prefix, opt$sample_id, sep = "_")
  seurat_obj <- CreateSeuratObject(counts = txi$counts, min.cells = 3, min.features = 200, project = project_name)
  
  # Save raw Seurat object
  saveRDS(seurat_obj, file = file.path(opt$output, paste0(opt$sample_id, "_Seurat_raw.rds")))

  # Fetch data for mitochondrial, hemoglobin, and ribosomal genes
  seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = mito_pattern)
  seurat_obj[["percent.hb"]] <- PercentageFeatureSet(seurat_obj, pattern = hb_pattern)
  if (length(ribo_patterns) > 0) {
    seurat_obj[["percent.ribo"]] <- PercentageFeatureSet(seurat_obj, pattern = ribo_patterns)
  }

  # Add number of genes per UMI for each cell to metadata
  seurat_obj[["log10GenesPerUMI"]] <- log10(seurat_obj$nFeature_RNA) / log10(seurat_obj$nCount_RNA)
    
  # Add percent expression of housekeeping genes to metadata
  if (exists("housekeeper_genes")) {
    # Get the RNA layer
    DefaultAssay(seurat_obj) <- "RNA"
    rna_data <- GetAssayData(seurat_obj, layer = 'counts')
    
    # Check if the housekeeping genes are present in the dataset
    common_genes <- intersect(rownames(rna_data), housekeeper_genes)
    
    if (length(common_genes) > 0) {
      # Compute housekeeping gene expression only if common genes are found
      seurat_obj[["percent.housekeeping"]] <- rowMeans(rna_data[common_genes, ]) / seurat_obj$nCount_RNA * 100
    } else {
      warning("No housekeeping genes found in the dataset.")
    }
  } else {
    warning("Housekeeping genes not defined.")
  }

    # Save plots
  output_file <- file.path(opt$output, paste0(opt$sample_id, "_QC1_plots.pdf"))
  pdf(output_file)
  
  # Visualize QC metrics as a violin plot
  VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo", "percent.hb", "percent.housekeeping"), 
          ncol = 6, pt.size = 0) + theme(legend.position = 'right')
  
  output_file <- file.path(opt$output, paste0(opt$sample_id, "_VlnPlots.pdf"))
  pdf(output_file)

  # Plot UMI Counts vs Percent Mito
  plot(seurat_obj$nCount_RNA, seurat_obj$percent.mt, main = "UMI Counts x Percent Mito", xlab = "UMI_count", ylab = "percent mito")
  output_file <- file.path(opt$output, paste0(opt$sample_id, "_QC2_plots.pdf"))
  dev.off()  
  
  # Filter using command-line arguments
  seurat_obj_filtered <- subset(seurat_obj, subset = nFeature_RNA > opt$min_genes & 
                                              nFeature_RNA < opt$max_genes & 
                                              percent.mt < opt$max_mito & 
                                              percent.housekeeping > opt$min_housekeeping_expr)

  # Optionally remove ribosomal genes
  if (opt$remove_ribo && length(ribo_patterns) > 0) {
    ribo_genes <- grep(paste(ribo_patterns, collapse = "|"), rownames(seurat_obj), value = TRUE)
    seurat_obj_filtered <- seurat_obj_filtered[!(rownames(seurat_obj_filtered) %in% ribo_genes), ]
  }

  # Save filtered QC plots
  filtered_output_file <- file.path(opt$output, paste0(opt$sample_id, "_filtered_QC1_plots.pdf"))
  pdf(filtered_output_file)
  
  # Visualize QC metrics for filtered data
  VlnPlot(seurat_obj_filtered, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo", "percent.hb", "percent.housekeeping"), 
          ncol = 6, pt.size = 0) + theme(legend.position = 'right')
  
  filtered_output_file <- file.path(opt$output, paste0(opt$sample_id, "_filtered_VlnPlots.pdf"))
  pdf(filtered_output_file)

  # Plot UMI Counts vs Percent Mito for filtered data
  plot(seurat_obj_filtered$nCount_RNA, seurat_obj_filtered$percent.mt, main = "UMI Counts x Percent Mito (Filtered)", xlab = "UMI_count", ylab = "percent mito")
  filtered_output_file <- file.path(opt$output, paste0(opt$sample_id, "_filtered_QC1_plots.pdf"))
  pdf(filtered_output_file)
  dev.off() 

  counts_data <- GetAssayData(seurat_obj_filtered, slot = 'counts')
  singleR_results <- SingleR(test = counts_data, ref = combined, labels = combined$label.main)
  
  # Add SingleR results to metadata
  seurat_obj_filtered$singleR.labels <- singleR_results$labels[match(rownames(seurat_obj_filtered@meta.data), rownames(singleR_results))]
  
  # Save SingleR annotation plot
  singleR_output_file <- file.path(opt$output, paste0(opt$sample_id, "_SingleR_annotation.pdf"))
  pdf(singleR_output_file)
  dev.off()  

  # Save filtered object with SingleR metadata
  saveRDS(seurat_obj_filtered, file = file.path(opt$output, paste0(opt$sample_id, "_SingleR_filtered.rds")))

  # Cell Cycle Scoring and Regression (if option is enabled)
  if (opt$cell_cycle_regression) {
    # Load cell cycle genes
    s.genes <- cc.genes$s.genes
    g2m.genes <- cc.genes$g2m.genes
    # Perform Cell Cycle Scoring
    seurat_obj_filtered <- CellCycleScoring(seurat_obj_filtered, s.features = s.genes, g2m.features = g2m.genes)
    # Perform Cell Cycle Regression
    seurat_obj_filtered <- ScaleData(seurat_obj_filtered, vars.to.regress = c("S.Score", "G2M.Score"), features = rownames(seurat_obj_filtered))
  }

# Sex Scoring (if option is enabled)
if (opt$sex_scoring) {
  seurat_obj_filtered <- SexScoring(
    object = seurat_obj_filtered, 
    female.features = female.features, 
    male.features = male.features, 
    set.ident = TRUE
  )

  # Calculate Sex Difference
  seurat_obj_filtered$Sex.Difference <- seurat_obj_filtered$Female.Score - seurat_obj_filtered$Male.Score
  # Perform Sex Regression
  seurat_obj_filtered <- ScaleData(seurat_obj_filtered, vars.to.regress = "Sex.Difference", features = rownames(seurat_obj_filtered))
  # PCA Analysis on Sex-related Genes
  PCA_sex <- RunPCA(seurat_obj_filtered, features = c(male.features, female.features))
  
  # Save PCA Plot as PDF
  pca_sex_output_file <- file.path(opt$output, paste0(opt$sample_id, "_PCA_Sex.pdf"))
  pdf(pca_sex_output_file)
  DimPlot(PCA_sex)
  dev.off()
  }

  # Additional steps: Normalization, Variable Feature Identification, Scaling, PCA, Clustering, UMAP
  seurat_obj_filtered <- NormalizeData(object = seurat_obj_filtered)
  seurat_obj_filtered <- FindVariableFeatures(object = seurat_obj_filtered)
  seurat_obj_filtered <- ScaleData(object = seurat_obj_filtered)
  seurat_obj_filtered <- RunPCA(object = seurat_obj_filtered)
  
  # Save PCA Elbow plot
  pca_output_file <- file.path(opt$output, paste0(opt$sample_id, "_PCA.pdf"))
  pdf(pca_output_file)
  ElbowPlot(seurat_obj_filtered)
  elbow_output_file <- file.path(opt$output, paste0(opt$sample_id, "_ElbowPlot.pdf"))
  pdf(elbow_output_file)
    dev.off()

  seurat_obj_filtered <- FindNeighbors(object = seurat_obj_filtered, dims = 1:20)
  seurat_obj_filtered <- FindClusters(object = seurat_obj_filtered)
  seurat_obj_filtered <- RunUMAP(object = seurat_obj_filtered, dims = 1:20)
  
  # Save UMAP plot
  umap_output_file <- file.path(opt$output, paste0(opt$sample_id, "_UMAP.pdf"))
  pdf(umap_output_file)

  DimPlot(seurat_obj_filtered, reduction = "umap", label = TRUE, pt.size = 0.5) + theme(legend.position = 'right')
  dimplot_output_file <- file.path(opt$output, paste0(opt$sample_id, "_UMAP.pdf"))
  pdf(dimplot_output_file)
  dev.off()
  
  # Save final filtered object
  saveRDS(seurat_obj_filtered, file = file.path(opt$output, paste0(opt$sample_id, "_final_filtered.rds")))

  ### Monocle3 Analysis ###
  # Convert Seurat object to monocle3 object
  cds <- as.cell_data_set(seurat_obj_filtered)
  # Preprocess the data
  cds <- preprocess_cds(cds, num_dim = 50)
  # Reduce dimensions using UMAP
  cds <- reduce_dimension(cds, umap.n_neighbors = 30, umap.min_dist = 0.1)
  # Cluster cells
  cds <- cluster_cells(cds)
  # Learn trajectory graph
  cds <- learn_graph(cds)
  # Order cells in pseudotime
  cds <- order_cells(cds)

  # Save monocle3 trajectory plot
  monocle_output_file <- file.path(opt$output, paste0(opt$sample_id, "_monocle_trajectory.pdf"))
  pdf(monocle_output_file)
  plot_cells(cds, color_cells_by = "pseudotime", label_groups_by_cluster = FALSE, label_leaves = TRUE, label_branch_points = TRUE)
  plot_cells_output_file <- file.path(opt$output, paste0(opt$sample_id, "_monocle_plot.pdf"))
  pdf(plot_cells_output_file)
  dev.off()

  # Save monocle3 object
  saveRDS(cds, file = file.path(opt$output, paste0(opt$sample_id, "_monocle3_cds.rds")))
}